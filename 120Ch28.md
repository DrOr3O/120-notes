# Locks

## Basic idea
```C
lock_tmutex;//someglobally-allocatedlock’mutex’ 
lock(&mutex);
balance=balance+1;
unlock(&mutex);
```
- example of how the lock works for critical section
- lock variable holds the state of lock at any instant in any time (free or held)

## Pthread locks
- POSIX library => mutex (mutual exclusion)
```C
pthread_mutex_tlock=PTHREAD_MUTEX_INITIALIZER;
Pthread_mutex_lock(&lock);//wrapper;exitsonfailure 
balance=balance+1;
Pthread_mutex_unlock(&lock);
```
- passing different to provide more fine grained approach

## evaluating lock
1. provide mutual exclusion
2. fairness, how does threads decide who get the lock next
3. performance

## controlling Interrupts
1. first approach is make lock disable interrupt
    - positive:
        - simple
    - negative:
        - allow any calling threads to do privilege operation
        - doesn't stop multiprocessors
        - interrupts might get lost 
        - inefficient
2. Use Loads/Stores (failed)
    - single flag doesn't work because:
        - correctness
        - Spin-waiting wastes time waiting for another thread to release a lock
3. Test and Set for working spin locks
    - hardware support for the system
    - test and set (atomic exchange) instruction
    ```C
    intTestAndSet(int*old_ptr,intnew){
        intold=*old_ptr;//fetcholdvalueatold_ptr 
        old_ptr=new;//store’new’intoold_ptr 
        returnold;//returntheoldvalue 
    }
    ```
    - test old value and set new value in one single atomic operation
    - type of spin lock, works on CPU cycle
    - preemptive scheduler to work one single processor, change thread on timer
4. Evaluating spin lock



